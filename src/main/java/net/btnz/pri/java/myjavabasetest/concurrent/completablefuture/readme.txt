Future 是Java 5添加的类，用来描述一个异步计算的结果。你可以使用
isDone 方法检查计算是否完成，或者使用 get 阻塞住调用线程，
直到计算完成返回结果，你也可以使用 cancel 方法停止任务的执行。

虽然 Future 以及相关使用方法提供了异步执行任务的能力，
但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式
得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，
轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果，
为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？



函数式接口(Functional Interface)是Java 8对一类特殊类型的接口的称呼。
这类接口只定义了唯一的抽象方法的接口（除了隐含的Object对象的公共方
法）， 因此最开始也就做SAM类型的接口（Single Abstract Method）。
为什么会单单从接口中定义出此类接口呢？ 原因是在Java Lambda的实现
中，开发组不想再为Lambda表达式单独定义一种特殊的Structural函数
类型，称之为箭头类型（arrow type）， 依然想采用Java既有的类型系
统(class, interface, method等)， 原因是增加一个结构化的函数类型
会增加函数类型的复杂性，破坏既有的Java类型，并对成千上万的Java类
库造成严重的影响。权衡利弊，因此最终还是利用SAM 接口作为 Lambda表
达式的目标类型。JDK中已有的一些接口本身就是函数式接口，如Runnable。
JDK 8中又增加了java.util.function包，提供了常用的函数式接口。
函数式接口代表的一种契约，一种对某个特定函数类型的契约。在它出现的
地方，实际期望一个符合契约要求的函数。 Lambda表达式不能脱离上下文
而存在，它必须要有一个明确的目标类型，而这个目标类型就是某个函数式
接口。


